// script.js
(function () {
  function qs(sel, root = document) { return root.querySelector(sel); }
  function qsa(sel, root = document) { return Array.from(root.querySelectorAll(sel)); }

  function escapeHtml(str) {
    return String(str)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function splitParagraphs(text) {
    const t = String(text || "").trim();
    if (!t) return [];
    // tenta respeitar quebras e separadores comuns em CSV
    const parts = t
      .replace(/\r\n/g, "\n")
      .replace(/\r/g, "\n")
      .split(/\n{2,}|\s*\|\s*/g)
      .map(s => s.trim())
      .filter(Boolean);
    return parts.length ? parts : [t];
  }

  function detectDelimiter(line) {
    const commas = (line.match(/,/g) || []).length;
    const semis = (line.match(/;/g) || []).length;
    return semis > commas ? ";" : ",";
  }

  // CSV simples (suporta aspas)
  function parseCSV(text) {
    const raw = String(text || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n").trim();
    if (!raw) return { headers: [], rows: [] };

    const lines = raw.split("\n").filter(l => l.trim().length);
    if (!lines.length) return { headers: [], rows: [] };

    const delim = detectDelimiter(lines[0]);

    function parseLine(line) {
      const out = [];
      let cur = "";
      let inQuotes = false;

      for (let i = 0; i < line.length; i++) {
        const ch = line[i];

        if (ch === '"') {
          // escape "" dentro de aspas
          if (inQuotes && line[i + 1] === '"') {
            cur += '"';
            i++;
          } else {
            inQuotes = !inQuotes;
          }
          continue;
        }

        if (!inQuotes && ch === delim) {
          out.push(cur.trim());
          cur = "";
          continue;
        }

        cur += ch;
      }
      out.push(cur.trim());
      return out;
    }

    const first = parseLine(lines[0]);
    const hasHeader = first.some(v => /[A-Za-zÀ-ÖØ-öø-ÿ]/.test(v)) && first.every(v => v.length > 0);

    const headers = hasHeader ? first : first.map((_, i) => `col_${i + 1}`);
    const start = hasHeader ? 1 : 0;

    const rows = [];
    for (let i = start; i < lines.length; i++) {
      const vals = parseLine(lines[i]);
      if (vals.every(v => !v)) continue;

      const obj = {};
      headers.forEach((h, idx) => { obj[h] = vals[idx] ?? ""; });
      rows.push(obj);
    }

    return { headers, rows };
  }

  function pickField(obj, keys) {
    const lower = Object.keys(obj).reduce((acc, k) => {
      acc[k.toLowerCase()] = k;
      return acc;
    }, {});

    for (const k of keys) {
      const lk = k.toLowerCase();
      if (lower[lk]) return obj[lower[lk]];
      // busca parcial
      const found = Object.keys(lower).find(x => x.includes(lk));
      if (found) return obj[lower[found]];
    }
    return "";
  }

  function buildAccordionItem({ prefix, title, desc, body }) {
    const safePrefix = escapeHtml(prefix);
    const safeTitle = escapeHtml(title);
    const safeDesc = escapeHtml(desc);

    const labelText = [prefix, title || desc].filter(Boolean).join(" ");
    const btnDataText = escapeHtml(labelText);

    const paragraphs = splitParagraphs(body);
    const innerHTML = paragraphs.map(p => `<p>${escapeHtml(p)}</p>`).join("");

    return `
      <div class="acc-item" data-open="false">
        <button class="acc-btn" type="button" aria-expanded="false" data-text="${btnDataText}">
          <span class="acc-label">
            ${safePrefix ? `<span class="acc-prefix">${safePrefix}</span> ` : ""}
            <span class="acc-desc">${safeTitle || safeDesc}</span>
          </span>
          <span class="acc-icon" aria-hidden="true">
            <span class="acc-plus">+</span>
            <span class="acc-minus">−</span>
          </span>
        </button>
        <div class="acc-panel" aria-hidden="true">
          <div class="acc-inner">${innerHTML}</div>
        </div>
      </div>
    `;
  }

  function closeItem(item) {
    item.dataset.open = "false";
    const btn = qs(".acc-btn", item);
    const panel = qs(".acc-panel", item);
    btn.setAttribute("aria-expanded", "false");
    panel.setAttribute("aria-hidden", "true");
    panel.style.maxHeight = "0px";
  }

  function openItem(item) {
    item.dataset.open = "true";
    const btn = qs(".acc-btn", item);
    const panel = qs(".acc-panel", item);
    btn.setAttribute("aria-expanded", "true");
    panel.setAttribute("aria-hidden", "false");

    // animação suave (max-height)
    panel.style.maxHeight = panel.scrollHeight + "px";
  }

  function wireAccordion(root) {
    const items = qsa(".acc-item", root);

    items.forEach((item) => {
      const btn = qs(".acc-btn", item);
      const panel = qs(".acc-panel", item);

      // estado inicial
      panel.style.maxHeight = "0px";

      btn.addEventListener("click", () => {
        const isOpen = item.dataset.open === "true";

        // comportamento: abre um por vez (mais limpo pro “menu”)
        items.forEach(it => { if (it !== item) closeItem(it); });

        if (isOpen) closeItem(item);
        else {
          openItem(item);
          // garante altura correta após o repaint
          requestAnimationFrame(() => {
            panel.style.maxHeight = panel.scrollHeight + "px";
          });
        }
      });
    });

    // mantém alturas se redimensionar
    window.addEventListener("resize", () => {
      items.forEach((item) => {
        if (item.dataset.open === "true") {
          const panel = qs(".acc-panel", item);
          panel.style.maxHeight = panel.scrollHeight + "px";
        }
      });
    });
  }

  async function loadAccordionFromCSV(root) {
    // tenta múltiplos caminhos (normalização/encoding do nome com acento)
    const precomposed = "listagem acorde\u00e3o.csv"; // acordeão
    const decomposed = "listagem acorde" + "a\u0303" + "o.csv"; // acordeão (a + combining tilde)
    const candidates = [
      "./" + precomposed,
      "./" + decomposed,
      precomposed,
      decomposed,
      "listagem%20acorde%C3%A3o.csv",
      "listagem%20acordea%CC%83o.csv"
    ];

    let csvText = "";
    for (const url of candidates) {
      try {
        const res = await fetch(url, { cache: "no-cache" });
        if (res && res.ok) {
          csvText = await res.text();
          break;
        }
      } catch (_) {}
    }

    if (!csvText) {
      // fallback mínimo (caso extremo). Mantém o layout funcionando.
      const fallback = [
        { prefix: "/01", title: "diagnóstico e posicionamento", desc: "", body: "" },
        { prefix: "/02", title: "direção criativa e editorial", desc: "", body: "" },
        { prefix: "/03", title: "social e conteúdo", desc: "", body: "" },
        { prefix: "/04", title: "influência e relações", desc: "", body: "" },
        { prefix: "/05", title: "lançamentos", desc: "", body: "" }
      ];

      root.innerHTML = fallback.map(buildAccordionItem).join("");
      wireAccordion(root);
      return;
    }

    const { rows } = parseCSV(csvText);

    const items = rows.map((row, idx) => {
      const prefix =
        pickField(row, ["prefix", "numero", "n", "id", "ordem"]) ||
        (() => {
          // tenta achar algo que pareça “/01”
          const vals = Object.values(row).map(v => String(v || "").trim());
          const found = vals.find(v => /^\/?\d{1,2}([./-]\d{1,2})?$/.test(v));
          if (found) return found.startsWith("/") ? found : "/" + found;
          return "/" + String(idx + 1).padStart(2, "0");
        })();

      const title =
        pickField(row, ["titulo", "title", "módulo", "modulo", "nome", "name"]) ||
        pickField(row, ["col_2", "col_1"]);

      const desc =
        pickField(row, ["subtitulo", "subtítulo", "desc", "descricao", "descrição", "resumo"]) ||
        "";

      // corpo: pega o campo mais “longo” ou um campo típico de conteúdo
      let body =
        pickField(row, ["texto", "conteudo", "conteúdo", "body", "detalhes", "detalhe", "copy"]) ||
        "";
      if (!body) {
        const vals = Object.values(row).map(v => String(v || ""));
        body = vals.sort((a, b) => b.length - a.length)[0] || "";
      }

      return { prefix, title, desc, body };
    });

    root.innerHTML = items.map(buildAccordionItem).join("");
    wireAccordion(root);
  }

  function setupHamburger() {
    const headerBar = qs("#header-bar");
    const hamburger = qs("#hamburger");
    const mobileMenu = qs("#mobile-menu");
    if (!headerBar || !hamburger || !mobileMenu) return;

    function positionMobileMenu() {
      const rect = headerBar.getBoundingClientRect();
      mobileMenu.style.top = Math.round(rect.bottom) + "px";
    }

    function openMenu() {
      positionMobileMenu();
      mobileMenu.classList.add("active");
      mobileMenu.setAttribute("aria-hidden", "false");
      hamburger.setAttribute("aria-expanded", "true");
      hamburger.classList.add("open");
    }

    function closeMenu() {
      mobileMenu.classList.remove("active");
      mobileMenu.setAttribute("aria-hidden", "true");
      hamburger.setAttribute("aria-expanded", "false");
      hamburger.classList.remove("open");
    }

    hamburger.addEventListener("click", (e) => {
      e.stopPropagation();
      const isOpen = mobileMenu.classList.contains("active");
      if (isOpen) closeMenu();
      else openMenu();
    });

    // fecha ao clicar em link
    qsa("a", mobileMenu).forEach(a => a.addEventListener("click", closeMenu));

    // fecha ao clicar fora
    document.addEventListener("click", (e) => {
      if (!mobileMenu.classList.contains("active")) return;
      const target = e.target;
      if (mobileMenu.contains(target) || hamburger.contains(target)) return;
      closeMenu();
    });

    // mantém o menu sempre “colado” abaixo da barra (quando sticky muda de posição)
    window.addEventListener("scroll", () => {
      if (mobileMenu.classList.contains("active")) positionMobileMenu();
    }, { passive: true });

    window.addEventListener("resize", () => {
      if (mobileMenu.classList.contains("active")) positionMobileMenu();
    });
  }

  function setupImageFallbacks() {
    qsa("img[data-fallback]").forEach((img) => {
      img.addEventListener("error", () => {
        const fb = img.getAttribute("data-fallback");
        if (!fb) return;
        img.src = fb;
        img.removeAttribute("data-fallback");
      }, { once: true });
    });
  }

  document.addEventListener("DOMContentLoaded", () => {
    setupImageFallbacks();
    setupHamburger();

    const accordionRoot = qs("#accordion");
    if (accordionRoot) loadAccordionFromCSV(accordionRoot);
  });
})();
